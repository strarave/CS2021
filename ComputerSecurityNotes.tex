\documentclass[10pt,a4paper]{article}

\usepackage{float}
\usepackage{graphicx}

\title{Computer Security}
\author{Elia Ravella}
\begin{document}
	\begin{titlepage}
		\maketitle
	\end{titlepage}
	
	\tableofcontents
	\clearpage
	
	\part{Introduction} 
		%% shellcoder's handbook, C. Anley and J. Heasman
		\section{Security}
			What is security? First, we need to distinguish \emph{security} itself and \emph{safety}; the first represents a system that protects from the outside, the second a system that does not harm when it's used.
			
			\subsection{What is a secure system and how to engineer one}
				Famous triangle problem, this time with CIA properties
				\begin{itemize}
					\item Confidentiality: only authorized entities can access information
					\item Integrity: only authorized entities can modify information;
					\item Availabilty: data must be available to all authorized entities in a determined time constraint.
				\end{itemize}
				"You can take only two" problem: A conflicts with C and I.\\
				System security is an engineering problem: it's crucial to find an \emph{optimal tradeoff} between properties to be ensured, and costs to be faced when securing such properties.
			
			\subsection{Entities in a secure system}
				\begin{itemize}
					\item Vulnerability: something that allows to violate one of the CIA properties. It can be something as a design errors, a construction error, or a use defect. Even an \emph{inherent property} of a system can be a vulnerability.
					\item Exploit: a specific way to use a vulnerability (or more) to violate one of CIA properties.
					\item Asset: values of a system, properties that must be protected. Depending on the context a system operates in, different assets can be defined (soldier - armor - life).
					\item Threat: \textbf{possible / potential} violation of CIA constraints. A threat is linked to a threat agent, that's the actual physical person / system that performs the potential attack.
					\item Attack: \textbf{intentional} use of an exploit to violate CIA properties.
					\item Risks: combination of assets, vulnerabilities and threats. Formally (using economic value) they're A*V*T. Risk management takes care of the first two properties. The security problem is to manage the reduction of vulnerabilities and the recovery / mitigation plan. 
				\end{itemize}
				\textbf{A vulnerability can be present without any exploits. An exploit depends from a set of vulnerabilities}.\\
				
				\paragraph{Security vs Cost Balance}
					As usual, costs can be separated in direct and indirect costs. In this scenario, direct costs are related to the actual put-in-place of a solution. Indirect costs, instead are all the user experience costs, all those experience-heaving procedures, for example. So EVERY SINGLE SECURITY SOLUTION ADDS A COST.
					
				\paragraph{Trust and Boundaries}
					The security problem must have boundaries, otherwise it will cover over the universe. So, subparts must become \emph{trusted} and be \emph{assumed secure}. All the system that are beyond (below) the boundary are assumed secure too. The trusted element is the one to be tested most. 
			
			
				
	\part{Cryptography}
		\section{Cryptography, cryptoanalisys, cryptology}
			Cryptography is the building of secure mathematical systems. Cryptoanalisys is the discipline of analyzing such systems, and trying to break them. Cryptology is the union of both.\\
			Cryptography \emph{as a discipline} was formalized by Claude Shannon in 1949. The (still actual) formalization of a cryptosystem is composed of 3 main components:
			\begin{enumerate}
				\item the \emph{plaintext}, the message to be encoded
				\item the reversible \emph{key}
				\item the \emph{cyphertext}, the encoded message
			\end{enumerate}
			
			\subsection{Confidentiality and Integrity}
				"Why a cryptosystem"? The two main features that a cryptosystem must have are
				\begin{enumerate}
					\item confidentiality: only the recipients can read and utilize the information in the message.
					\item integrity: data can't be altered in the message passing. If so, the recipient can detect the change.
				\end{enumerate}
				The Kerchoff's principles states that the security of a cryptosystem relies \emph{solely} on the secrecy of the key, rather than the secrecy of the algorithm. This, in fact, should remain public. This means that a secure system is \emph{transparent} inherently.\\
				\textbf{The key must be the trusted element of the entire cryptographic system}.\\
				Formally, a perfect cypher does not leak any information about the message if and only of
				\begin{equation}
					P(M=m \,\vert\, C=c) = P(M=m)
				\end{equation}
				As theorized by Shannon. So "the probability of observing message m given cypher c is indipendent from the cypher given". Shannon also proved that perfect cyphers exists: they're \emph{one time non reusable key systems, with the lenght of the key equal to the lenght of the message} (also known as the \textbf{Shannon Theorem)}.\\
				The only perfect cypher implementation is OTP, One Time Pad. Classic XOR based encryption with a one time password (pre shared) that is long as the message. The cool thing about perfect cyphers such as OTP is that bruteforcing the cyphertext simply returns all the possible combination of plaintext, rendering so useless the brutaforce approach.
			
			\subsection{Cryptoanalysis}
				All the "brutaforce" fuss is about the problem of determining "how much a system is breakable". Bruteforce "always works", but it's a costly approach. So, it formally represents an \emph{upper bound} to the decyfering provedure complexity for that cypher. Other (more smart) attacks are 
				\begin{itemize}
					\item Cyphertext attack - only cyphered text are available, a key/algorithm leak of information must be exploited
					\item Known plaintext attack - comparation between the plain and crypted texts should lead to the key
					\item Chosen plaintext attack - reverse engineering of the algorithm
				\end{itemize}
				distinguished by the materials available to the attacker, and orderd in increasing complexity.
				
			\subsection{Remarks on Cryptosystems}
				\begin{enumerate}
					\item Security of a CS is based on the robustness of the \emph{algorithm}
					\item No algorithm is invulnerable to brute force attacks, exceptionmade for \emph{one time pads}
					\item An algorithm is said to be broken if there's at least one way \emph{faster than bruteforce} to bypass it
					\item THe only way to prove a cypher is robust is to try to break it
				\end{enumerate}
		
		\section{Symmetric Encryption}
			Classic: Alice uses key K to encrypt message M into cypher C, then Bob uses the very same key K to decypher cypher C into message M. Problem: exchanging keys. We need a \emph{trusted separated channel} to exchange the key. What is a trusted channel? It generally is a different channel that both the recipients \emph{consider trusted} and generally \emph{requires a different attack to be violated}.\\
			We so must try to find a way to send to all recipents the key \emph{in a secure way}. Another issue with symmetric encrypted communication is scalability, each pair of user in a network should have a unique key. 
			
			\subsection{How to build a secure symmetric system}
				Three characteristics are fundamental to ensure the robustness of a symmetric cypher:
				\begin{enumerate}
					\item \emph{Multi Alphabetical Cyphers}: to mask structure and repetition in the plaintext several target alphabets can be (must be) used at the same time.
					\item \emph{Transposition}: also called diffusion, it consists of "swapping the value of bits", messing with the order in which the plaintext is translated.
				\end{enumerate}
				
				\paragraph{Keyspace}
					With keyspace is intended the \emph{set of possible keys}. There's an exponential correlation between the size (rank) of this set and the temporal complexity of the brutaforce effort. This means that more possible keys (generally translated in "how many bits is the key made of") more the time needed to bruteforce the cypher. \emph{This is valid in the current silicon architecture computers. Quantum computations could change this}.
		
		\section{Asymmetric Encryption}
			Cyphers with \emph{two} directional keys instead of one. What is encrypted with key A can be decrypted with key B and viceversa. What you can't do is
			\begin{itemize}
				\item decrypt the key with the \emph{same} key you used to encrypt the key
				\item deduce (calculate) one key from another
			\end{itemize}
			This approach enables "public key scenarios" due to the asymmetricity of the encryption mechanism. The robustness of this methods relies on the function used to encrypt the plaintext, that must be easy to apply \emph{but difficult to reverse}.\\
			To make a public key scenario works we must add to the set of trusted elements (that contains the private keys) a \emph{trusted assumption}: "only Bob knows Bob's private keys".\\
			In asymmetric encryption the key lenght is an important measure of safeness. However, while in symmetric cypher the lenght of the key measure the number of decription attempts, in asymmetric cypher it measures the \emph{number of key-breaking attempts}. That implies that asymmetric cyphers are "easier" to crack because of the approach chosen to encrypt. This also means that asymmetric and symmetric cyphers cannot be compared only using the key lenght.
			
			\subsection{Hash Functions}
				A hash function is a function that maps an \emph{arbitrary lenght string} in input on a \emph{fixed lenght string} at the output. Usually, input strings lenght are much longer than output ones $\Rightarrow$ \emph{collisions}. A good hash function satisfies three properties:
				\begin{enumerate}
					\item preimage attack resistance: the function is \emph{hard to invert}.
					\item second preimage attack resistance: it must be difficult to find a input string that have the same hash to another one \emph{given} (if the function is not preimage resistant it's not second preimage resistant too. The opposite is not true tho).
					\item collision resistance: it must be hard to find 2 inputs with the same output.
				\end{enumerate}
				
				\subsubsection{Attacks to Hash Functions}
					Hash function may be broken. This means that it's possible to find the original text from the cyphertwxt \emph{faster than bruteforcing}, just as the definition of broken cryptosystem. Two methods are used to attack a hash function:
					
					\paragraph{Arbitrary Collision}
						This is a first/second preimage attack: the attacker tries to deduce $x \,\vert\, H(x) = h$ or, respectively, $y \,\vert\, y \neq x \wedge H(x) = H(y)$.\\
						Again, an hash function is broken if this can be completed \emph{faster than bruteforcing it}.
						
					\paragraph{Simplified Collision Attack}
						Exactly the same approach as the arbitrary collision attack, but exploiting some probabilistic aspects of the collision (birthday paradox).
				
				\subsubsection{Digital Signature}
					Classic digital signature mechanism: an hash function produces a digest of a document, that's then encrypted with the private key of the sender. The receiver (to both check for identity of the sender and the integrity of the document) does the same: hashes the document and produces a digest, that's then compared with the decrypted version of the received one.\\
					A big issue in this case is "who to trust". To estabilish a list of trusted elements the current infrastructure relies on Certification Authorities, a tree-like structure (a hierarchical group) of entities that each signs with a trusted key (a trusted role) the certificates.
			
	\part{Authentication}
		\section{Identification and Authentication}
			What's the difference between identification and authentication? The first represents the act of "telling your identity". Authentication means to \emph{proof} the stated identity. Authentication must be \emph{bidirectional} or \emph{mutual}: both entities must acknowledge each other identity and the proof.
			
			\subsection{Authentication factors}
				To identify someone, three methods can be used:
				\begin{enumerate}
					\item Authentication by "to know" factor (passwords, pins)
					\item Authentication by "to have" factor (cards, ids)
					\item Authentication by "to be" factor (fingerprint, voice)
				\end{enumerate}
				Multi factor authentication uses more than one factor to authenticate.
				
				\subsubsection{To Know Authentication}
					To Know authentication systems relies on something the user willing to authenticate remembers, or is supposed to know. These systems are low cost, are easy to deploy and easy to use (due to the spread of such systems). Systems basing on to know auth are systems that rely on passwords, pins, login data combination etc.\\
					On the other hand, the secrets the user is asked to keep can be easily stolen or guessed, or even cracked (bruteforced). 
					
					\paragraph{Countermeasure Against Password Wearing}
						Three different attacks can moved against a passwrod-secured system, each one has a valid countermeasure:
						\begin{enumerate}
							\item against snooping, it's valid to change password often;
							\item against cracking, it's useful to enforce complexity of the password;
							\item against guessing, it's useful to ask for a nonsense password, or at least not easy to pin to the user;
						\end{enumerate}
						A system cannot put in place all these countermeasure, because they are \emph{costly}: they heavy the use of a system (a system that asks for a 64 mixed characters every 2 days).
						
					\paragraph{Secure Password Exchange, Challenge Response}
						Authentication phase, exchange of messages between two entities A and B that mutually authenticate each other
						\begin{enumerate}
							\item A to B: This is my identity. Let me authenticate
							\item B to A: nice. Compute hash(random-data + secret) + random-data
							\item A to B: hash(random-data + secret)
							\item A to B: nice. Compute hash(random-shit + secret) + random-shit
							\item B to A: hash(random-data + secret + random-shit)
						\end{enumerate}
						Where secret is the password, generally. The supposition is that both entities \emph{know} the secret.
						
					\paragraph{Secure Password Storage}
						Passwords are the secret upon it's based the security of a system (an authenticating one, at least). How to enforce password security?\\
						To protect a file (data in general) the techniques are always the same: 
						\begin{itemize}
							\item Encyption
							\item Salting (modifying stored passwords to mitigate dictionary attack)
							\item Access Control
							\item Password Recovery procedures that not disclose sensitive infos
						\end{itemize}
				
				\subsubsection{To Have Authentication}
					To Have factor relies on \emph{a phisycal device / object} that must be associated to a person willing to authenticate. The problem remains the human factor: this time the security of the system depends on how the key (secret) is handled by the person associated to it.\\
					In any case, to have authentication system are low cost and offer a good level of security. On the other hand, they're hard to deploy, and the tokens / cards are easy to be lost or destroyed / compromised.
				
				\subsubsection{To Be Authentication}
					To be authentication asks the person willing to authenticate to prove to be who s/he declares to be by biometrically satisfy a costraint (like having a certain fingerprint, hand geometry, iris pattern...).\\
					Although this kind of authentication is very effective (it's \emph{really} difficult to emulate someone else's fingerprint) the list of disadvantages for biometric security systems is quite long:
					\begin{enumerate}
						\item They're hard to deploy and set up. Moreover, usually during the setup phase an invasive test must be performed
						\item The matching of the feature selected is non-deterministic: accepting or rejecting a person depends on a threshold of accuracy, and this can act differently from time to time
						\item They're not \emph{entirely} secure: a fingerprint can be cloned
						\item Biometric features \emph{change} over time
						\item Privacy issues: people \emph{may not want} to distribute personal features involved in a biometric security system
					\end{enumerate}
				
				\subsubsection{Single Sign On}
					Single sign on was proposed as a system to countermeasure to password reusing. This system is based on a 1-2 factors authentication and \emph{a single trusted host}. This is simply the "delegating authentication to someone else" method of authentication, the \emph{external auth} method. Two main approaches:
					\begin{itemize}
						\item SAML approach: an external service serves as authentication factor
						\item OAuth approach: the external service \emph{just helps the authentication}, giving the user a code in order to sign on to the principal service
					\end{itemize}
					This is also complicated to implement: an app should (in order to implement OAuth or SAML) complicate a lot its flow of usage (user experience) in order to just authenticate a user.\\
					Moreover, the trusted factor is a SPOF.
					
		\section{Access Control}
			Access control is all the protocols and procedures that \emph{allow or deny} certain operations to be applied on certain resources. This operation is usually performed by a reference monitor, that carries out the verification of the rules and the roles (lol).
			
			\subsection{Discretionary Access Control}
				The resource owner assigns the priviledges to users. It's the most standard access control system: for every user (or entity) a set of permissions is defined that describe the rights of each one. A DAC is defined by 3 set of entities:
				\begin{enumerate}
					\item subjects: the actors, the users
					\item objects: the resources
					\item actions: the actions that subjects can perform on objects, that are restricted by the rules
				\end{enumerate}
				The reference monitor organizes the subjects and the objects in a two entry map that lists what every user can do to each resource. This implementation is called HRU model, due to its designers. What this model also allow is to check if the access control system works as intended: if it can be proven that a user can "upgrade" his permissions \emph{on his own} the system is unsafe by design. This is an undecidable problem btw.\\
				This implementation (let alone the scaling problem) is a little bit difficult to utilize, so alternative implementations are possible, like:
				\begin{itemize}
					\item Authorization tables: DBMS like approach, it's a HRU model with not null entries
					\item Access control lists: used in networking, each objects records his own owners/users
					\item Capability list: each user "remembers" the authorization he got
				\end{itemize}
				See how the last two implementations are just "read the HRU table coloumn by coloumn" and "read the HRU table row by row".
				
			
			\subsection{Mandatory Access Control}
				Clearance / Sensitivity access control management. Based on user's roles combined with "objects' secrecy levels". The idea behind is: do not let users assign priviledges. The priviledges are set by an administrator, that assigns levels to users and to resources. Each user level can access only a subset of the resource level. This is usually combined with a labeling system that categorizes in a finer way the resources, orthogonally to the secrecy level.\\
				Then, read/write accesses are granted as rules, for example
				\begin{itemize}
					\item No read up
					\item No write down
				\end{itemize}
			
			\subsection{Role Based Access Control}
				RBAC is kinda a hybrid of DAC and MAC, and can also enforce them: if configured in the right way, it can act as a DAC or as a MAC. The idea is similar to the one that driven MAC design ("no self assigning dynamic priviledges") but the roles are no more structured in a rigid hierarchy but instead are simply \emph{a label to a set of priviledges}.
					
	\part{Software Security}		
		\section{What is software security?}
			With "software security" is intended the meeting of the non-functional requirement (obviously for a software) of \emph{being secure}. This is often overlooked in the process of software developing, but to remind the importance of this non functional requirement, it's sufficient to think about the name of the unmet security specifications: \textbf{vulnerability}.\\
			Recap on definitions:
			\begin{itemize}
				\item Vulnerability: fault in the target software/system
				\item Exploit: method to leverage a vulnerability to harm a system
			\end{itemize}
			
			\paragraph{Vulnerability / Attack relationship}
				\begin{figure}[H]
					\centering
					\includegraphics[width = \textwidth]{./images/vulLifeCycle.png}
				\end{figure}
				This graph explains how the vulnerability life cycle interacts with the actual attacks cycle to a software. To be noted:
				\begin{itemize}
					\item zero days attacks happens when the vulnerability is "out in the wild", known only to hackers
					\item at the moment the vulnerability is \emph{exposed to the public} other security firms can start working on side solutions to limit attacks, weakening the actual attackers margin
					\item the window of exposure is closed \emph{ONLY} after the patch is installed \emph{everywhere}
				\end{itemize}
				
		\section{Principles of Secure Design}
			We can define a list of principles, guidelines, to create a secure software:
			\begin{itemize}
				\item Reduce the privileged parts to the minimum to avoid permissions vulnerability windows
				\item KISS principle, reduce the complexity of a software
				\item Avoid shared resources, or unsafe external libraries. Use instead safe and known secure libraries
				\item Default deny principle: allow only authorized operations
				\item Use filters on input and output
			\end{itemize}
			
		\section{Vulnerabilities}
			\subsection{Buffer Overflow}
				Memory vulnerability, one of the most famous technique to exploit a software. Practically, it means that a piece of data is inserted in a buffer that is smaller. This enables the attacker to overwrite "sensitive" portion of the memory, and (in the worst case) inject malicious code. The thing that makes buffer overflow so dangerous is the way a buffer is allocated in 99\% of cases, so calling a function that does that: this allows the attacker to \emph{directly overwrite the return address from that function}.
			
	\part{Exercises and Examples}
		\section{Exercises}
			\subsection{Identity theft}
				Which are the risk components in the scenario of identity theft, like in social media platforms?
				\begin{enumerate}
					\item Reputation threathened both of the victim and the company
					\item Social engineering attacks
					\item Malicious spread of information
				\end{enumerate}
				And the assets?
				\begin{enumerate}
					\item reputation
					\item money
					\item personal information
				\end{enumerate}
				And who are the threat agents?
				\begin{enumerate}
					\item People around you
					\item Government
					\item etc
				\end{enumerate}
				So \emph{everybody} with a malicious intent\\
				Why is this scenario possible, and how to mitigate it?
				\begin{enumerate}
					\item 2FA
					\item trusted device based auth
					\item enforce credentials strongness
				\end{enumerate}
				
			\subsection{Ransomware attack}
				A small company specialized in a particular object is infected by a ransomware\\
				What are the threats, the asset at risk and the possible countermeasures?\\
				First:
				\begin{itemize}
					\item data loss
					\item data of the company
					\item offline backups
				\end{itemize}
				Second:
				\begin{itemize}
					\item data leakage
					\item data of the company
					\item encryption
				\end{itemize}
				Third:
				\begin{itemize}
					\item denial of service
					\item production
					\item redundancy
				\end{itemize}
				Who are the possible threat agents? Cuncurrent companies, ex internal employees, ransomers...
				
			\subsection{Auto driving vehicles}
				Consider auto driving cars used as taxies.\\
				Which are the most valuable assets in this scenario?
				\begin{enumerate}
					\item People inside the car
					\item People outside the car
					\item the vehicle itself
				\end{enumerate}
				What are the attack surfaces on the vehicles?
				\begin{enumerate}
					\item The VEHICLE itself, you enter there!
					\item the connectivity capabilities of the vehicle
					\item the company network, or the internet itself (it was an hypothesis)
				\end{enumerate}
				
	\part{x86 assembly recap and pwndbg}
		\section{Recap of software compiling}
			Code is translated by the compiler in Assembly code that is the assembled in binary code. That's the workflow. The process is theoretically not reversible, it can be reconduced to the halting problem. This is due to the loss of information (for example about types in the first step) that the process introduces.
			
		\section{The x86 ISA}
			64 bit CISC architecture for original Intel processors.\\
			Register file:
			\begin{enumerate}
				\item EAX EBX ECX EDX
				\item ESI EDI for strings
				\item EBP ESP base and stack pointers
				\item EIP instruction pointer, never explicitly accessed
				\item EFLAGS program status and control 
			\end{enumerate}
			The "E" before the register name stands for "extended" and references the 64 bit version of the register. Omitting it will access the 32 bit version.
			
			\subsection{Data types}
				Four main "data types"
				\begin{enumerate}
					\item Byte - 8 bit
					\item Word - 2 Bytes
					\item Dword - 2 Words
					\item Qword - 4 Words
				\end{enumerate}
			
			\subsection{Instructions}
				Instructions in x86 have \emph{variable lenght} ranging from 1 byte to 16 bytes. Every instruction is composed of the opcode (representing the operation) and the operand list. We'll be using logic, memory, arithmetic and control flow instructions.

		\section{Executables and binaries}
			Binary files, although different for each operative system, all (more or less) follow a fixed schema to encode operations and data. Usually, this schema involves a DATA and a TEXT section, respectively for the data and the instructions; it usually has also a section where offsets in memory (to describe the memory structure \emph{of the program}) are stored. Usually (starting from the lowest and going to the highest memory addresses) this is the schema:
			\begin{enumerate}
				\item Shared libraries
				\item .text
				\item .bss
				\item the heap (that grows \emph{towards high addresses})
				\item the stack (that grows \emph{towards low addresses})
				\item \emph{env}
				\item \emph{argv}
			\end{enumerate}
			



\end{document}
