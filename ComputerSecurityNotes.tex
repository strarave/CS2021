\documentclass[10pt,a4paper]{article}

\usepackage{float}
\usepackage{graphicx}
\usepackage{amsmath}

\title{Computer Security}
\author{Elia Ravella}
\begin{document}
	\begin{titlepage}
		\maketitle
	\end{titlepage}
	
	\tableofcontents
	\clearpage
	
	\part{Introduction} 
		%% shellcoder's handbook, C. Anley and J. Heasman
		\section{Security}
			What is security? First, we need to distinguish \emph{security} itself and \emph{safety}; the first represents a system that protects from the outside, the second a system that does not harm when it's used.
			
			\subsection{What is a secure system and how to engineer one}
				Famous triangle problem, this time with CIA properties
				\begin{itemize}
					\item Confidentiality: only authorized entities can access information
					\item Integrity: only authorized entities can modify information;
					\item Availabilty: data must be available to all authorized entities in a determined time constraint.
				\end{itemize}
				"You can take only two" problem: A conflicts with C and I.\\
				System security is an engineering problem: it's crucial to find an \emph{optimal tradeoff} between properties to be ensured, and costs to be faced when securing such properties.
			
			\subsection{Entities in a secure system}
				\begin{itemize}
					\item Vulnerability: something that allows to violate one of the CIA properties. It can be something as a design errors, a construction error, or a use defect. Even an \emph{inherent property} of a system can be a vulnerability.
					\item Exploit: a specific way to use a vulnerability (or more) to violate one of CIA properties.
					\item Asset: values of a system, properties that must be protected. Depending on the context a system operates in, different assets can be defined (soldier - armor - life).
					\item Threat: \textbf{possible / potential} violation of CIA constraints. A threat is linked to a threat agent, that's the actual physical person / system that performs the potential attack.
					\item Attack: \textbf{intentional} use of an exploit to violate CIA properties.
					\item Risks: combination of assets, vulnerabilities and threats. Formally (using economic value) they're A*V*T. Risk management takes care of the first two properties. The security problem is to manage the reduction of vulnerabilities and the recovery / mitigation plan. 
				\end{itemize}
				\textbf{A vulnerability can be present without any exploits. An exploit depends from a set of vulnerabilities}.\\
				
				\paragraph{Security vs Cost Balance}
					As usual, costs can be separated in direct and indirect costs. In this scenario, direct costs are related to the actual put-in-place of a solution. Indirect costs, instead are all the user experience costs, all those experience-heaving procedures, for example. So EVERY SINGLE SECURITY SOLUTION ADDS A COST.
					
				\paragraph{Trust and Boundaries}
					The security problem must have boundaries, otherwise it will cover over the universe. So, subparts must become \emph{trusted} and be \emph{assumed secure}. All the system that are beyond (below) the boundary are assumed secure too. The trusted element is the one to be tested most. 
			
			
				
	\part{Cryptography}
		\section{Cryptography, cryptoanalisys, cryptology}
			Cryptography is the building of secure mathematical systems. Cryptoanalisys is the discipline of analyzing such systems, and trying to break them. Cryptology is the union of both.\\
			Cryptography \emph{as a discipline} was formalized by Claude Shannon in 1949. The (still actual) formalization of a cryptosystem is composed of 3 main components:
			\begin{enumerate}
				\item the \emph{plaintext}, the message to be encoded
				\item the reversible \emph{key}
				\item the \emph{cyphertext}, the encoded message
			\end{enumerate}
			
			\subsection{Confidentiality and Integrity}
				"Why a cryptosystem"? The two main features that a cryptosystem must have are
				\begin{enumerate}
					\item confidentiality: only the recipients can read and utilize the information in the message.
					\item integrity: data can't be altered in the message passing. If so, the recipient can detect the change.
				\end{enumerate}
				The Kerchoff's principles states that the security of a cryptosystem relies \emph{solely} on the secrecy of the key, rather than the secrecy of the algorithm. This, in fact, should remain public. This means that a secure system is \emph{transparent} inherently.\\
				\textbf{The key must be the trusted element of the entire cryptographic system}.\\
				Formally, a perfect cypher does not leak any information about the message if and only of
				\begin{equation}
					P(M=m \,\vert\, C=c) = P(M=m)
				\end{equation}
				As theorized by Shannon. So "the probability of observing message m given cypher c is indipendent from the cypher given". Shannon also proved that perfect cyphers exists: they're \emph{one time non reusable key systems, with the lenght of the key equal to the lenght of the message} (also known as the \textbf{Shannon Theorem)}.\\
				The only perfect cypher implementation is OTP, One Time Pad. Classic XOR based encryption with a one time password (pre shared) that is long as the message. The cool thing about perfect cyphers such as OTP is that bruteforcing the cyphertext simply returns all the possible combination of plaintext, rendering so useless the brutaforce approach.
			
			\subsection{Cryptoanalysis}
				All the "brutaforce" fuss is about the problem of determining "how much a system is breakable". Bruteforce "always works", but it's a costly approach. So, it formally represents an \emph{upper bound} to the decyfering provedure complexity for that cypher. Other (more smart) attacks are 
				\begin{itemize}
					\item Cyphertext attack - only cyphered text are available, a key/algorithm leak of information must be exploited
					\item Known plaintext attack - comparation between the plain and crypted texts should lead to the key
					\item Chosen plaintext attack - reverse engineering of the algorithm
				\end{itemize}
				distinguished by the materials available to the attacker, and orderd in increasing complexity.
				
			\subsection{Remarks on Cryptosystems}
				\begin{enumerate}
					\item Security of a CS is based on the robustness of the \emph{algorithm}
					\item No algorithm is invulnerable to brute force attacks, exceptionmade for \emph{one time pads}
					\item An algorithm is said to be broken if there's at least one way \emph{faster than bruteforce} to bypass it
					\item THe only way to prove a cypher is robust is to try to break it
				\end{enumerate}
		
		\section{Symmetric Encryption}
			Classic: Alice uses key K to encrypt message M into cypher C, then Bob uses the very same key K to decypher cypher C into message M. Problem: exchanging keys. We need a \emph{trusted separated channel} to exchange the key. What is a trusted channel? It generally is a different channel that both the recipients \emph{consider trusted} and generally \emph{requires a different attack to be violated}.\\
			We so must try to find a way to send to all recipents the key \emph{in a secure way}. Another issue with symmetric encrypted communication is scalability, each pair of user in a network should have a unique key. 
			
			\subsection{How to build a secure symmetric system}
				Three characteristics are fundamental to ensure the robustness of a symmetric cypher:
				\begin{enumerate}
					\item \emph{Multi Alphabetical Cyphers}: to mask structure and repetition in the plaintext several target alphabets can be (must be) used at the same time.
					\item \emph{Transposition}: also called diffusion, it consists of "swapping the value of bits", messing with the order in which the plaintext is translated.
				\end{enumerate}
				
				\paragraph{Keyspace}
					With keyspace is intended the \emph{set of possible keys}. There's an exponential correlation between the size (rank) of this set and the temporal complexity of the brutaforce effort. This means that more possible keys (generally translated in "how many bits is the key made of") more the time needed to bruteforce the cypher. \emph{This is valid in the current silicon architecture computers. Quantum computations could change this}.
		
		\section{Asymmetric Encryption}
			Cyphers with \emph{two} directional keys instead of one. What is encrypted with key A can be decrypted with key B and viceversa. What you can't do is
			\begin{itemize}
				\item decrypt the key with the \emph{same} key you used to encrypt the key
				\item deduce (calculate) one key from another
			\end{itemize}
			This approach enables "public key scenarios" due to the asymmetricity of the encryption mechanism. The robustness of this methods relies on the function used to encrypt the plaintext, that must be easy to apply \emph{but difficult to reverse}.\\
			To make a public key scenario works we must add to the set of trusted elements (that contains the private keys) a \emph{trusted assumption}: "only Bob knows Bob's private keys".\\
			In asymmetric encryption the key lenght is an important measure of safeness. However, while in symmetric cypher the lenght of the key measure the number of decription attempts, in asymmetric cypher it measures the \emph{number of key-breaking attempts}. That implies that asymmetric cyphers are "easier" to crack because of the approach chosen to encrypt. This also means that asymmetric and symmetric cyphers cannot be compared only using the key lenght.
			
			\subsection{Hash Functions}
				A hash function is a function that maps an \emph{arbitrary lenght string} in input on a \emph{fixed lenght string} at the output. Usually, input strings lenght are much longer than output ones $\Rightarrow$ \emph{collisions}. A good hash function satisfies three properties:
				\begin{enumerate}
					\item preimage attack resistance: the function is \emph{hard to invert}.
					\item second preimage attack resistance: it must be difficult to find a input string that have the same hash to another one \emph{given} (if the function is not preimage resistant it's not second preimage resistant too. The opposite is not true tho).
					\item collision resistance: it must be hard to find 2 inputs with the same output.
				\end{enumerate}
				
				\subsubsection{Attacks to Hash Functions}
					Hash function may be broken. This means that it's possible to find the original text from the cyphertwxt \emph{faster than bruteforcing}, just as the definition of broken cryptosystem. Two methods are used to attack a hash function:
					
					\paragraph{Arbitrary Collision}
						This is a first/second preimage attack: the attacker tries to deduce $x \,\vert\, H(x) = h$ or, respectively, $y \,\vert\, y \neq x \wedge H(x) = H(y)$.\\
						Again, an hash function is broken if this can be completed \emph{faster than bruteforcing it}.
						
					\paragraph{Simplified Collision Attack}
						Exactly the same approach as the arbitrary collision attack, but exploiting some probabilistic aspects of the collision (birthday paradox).
				
				\subsubsection{Digital Signature}
					Classic digital signature mechanism: an hash function produces a digest of a document, that's then encrypted with the private key of the sender. The receiver (to both check for identity of the sender and the integrity of the document) does the same: hashes the document and produces a digest, that's then compared with the decrypted version of the received one.\\
					A big issue in this case is "who to trust". To estabilish a list of trusted elements the current infrastructure relies on Certification Authorities, a tree-like structure (a hierarchical group) of entities that each signs with a trusted key (a trusted role) the certificates.
			
	\part{Authentication}
		\section{Identification and Authentication}
			What's the difference between identification and authentication? The first represents the act of "telling your identity". Authentication means to \emph{proof} the stated identity. Authentication must be \emph{bidirectional} or \emph{mutual}: both entities must acknowledge each other identity and the proof.
			
			\subsection{Authentication factors}
				To identify someone, three methods can be used:
				\begin{enumerate}
					\item Authentication by "to know" factor (passwords, pins)
					\item Authentication by "to have" factor (cards, ids)
					\item Authentication by "to be" factor (fingerprint, voice)
				\end{enumerate}
				Multi factor authentication uses more than one factor to authenticate.
				
				\subsubsection{To Know Authentication}
					To Know authentication systems relies on something the user willing to authenticate remembers, or is supposed to know. These systems are low cost, are easy to deploy and easy to use (due to the spread of such systems). Systems basing on to know auth are systems that rely on passwords, pins, login data combination etc.\\
					On the other hand, the secrets the user is asked to keep can be easily stolen or guessed, or even cracked (bruteforced). 
					
					\paragraph{Countermeasure Against Password Wearing}
						Three different attacks can moved against a passwrod-secured system, each one has a valid countermeasure:
						\begin{enumerate}
							\item against snooping, it's valid to change password often;
							\item against cracking, it's useful to enforce complexity of the password;
							\item against guessing, it's useful to ask for a nonsense password, or at least not easy to pin to the user;
						\end{enumerate}
						A system cannot put in place all these countermeasure, because they are \emph{costly}: they heavy the use of a system (a system that asks for a 64 mixed characters every 2 days).
						
					\paragraph{Secure Password Exchange, Challenge Response}
						Authentication phase, exchange of messages between two entities A and B that mutually authenticate each other
						\begin{enumerate}
							\item A to B: This is my identity. Let me authenticate
							\item B to A: nice. Compute hash(random-data + secret) + random-data
							\item A to B: hash(random-data + secret)
							\item A to B: nice. Compute hash(random-shit + secret) + random-shit
							\item B to A: hash(random-data + secret + random-shit)
						\end{enumerate}
						Where secret is the password, generally. The supposition is that both entities \emph{know} the secret.
						
					\paragraph{Secure Password Storage}
						Passwords are the secret upon it's based the security of a system (an authenticating one, at least). How to enforce password security?\\
						To protect a file (data in general) the techniques are always the same: 
						\begin{itemize}
							\item Encyption
							\item Salting (modifying stored passwords to mitigate dictionary attack)
							\item Access Control
							\item Password Recovery procedures that not disclose sensitive infos
						\end{itemize}
				
				\subsubsection{To Have Authentication}
					To Have factor relies on \emph{a phisycal device / object} that must be associated to a person willing to authenticate. The problem remains the human factor: this time the security of the system depends on how the key (secret) is handled by the person associated to it.\\
					In any case, to have authentication system are low cost and offer a good level of security. On the other hand, they're hard to deploy, and the tokens / cards are easy to be lost or destroyed / compromised.
				
				\subsubsection{To Be Authentication}
					To be authentication asks the person willing to authenticate to prove to be who s/he declares to be by biometrically satisfy a costraint (like having a certain fingerprint, hand geometry, iris pattern...).\\
					Although this kind of authentication is very effective (it's \emph{really} difficult to emulate someone else's fingerprint) the list of disadvantages for biometric security systems is quite long:
					\begin{enumerate}
						\item They're hard to deploy and set up. Moreover, usually during the setup phase an invasive test must be performed
						\item The matching of the feature selected is non-deterministic: accepting or rejecting a person depends on a threshold of accuracy, and this can act differently from time to time
						\item They're not \emph{entirely} secure: a fingerprint can be cloned
						\item Biometric features \emph{change} over time
						\item Privacy issues: people \emph{may not want} to distribute personal features involved in a biometric security system
					\end{enumerate}
				
				\subsubsection{Single Sign On}
					Single sign on was proposed as a system to countermeasure to password reusing. This system is based on a 1-2 factors authentication and \emph{a single trusted host}. This is simply the "delegating authentication to someone else" method of authentication, the \emph{external auth} method. Two main approaches:
					\begin{itemize}
						\item SAML approach: an external service serves as authentication factor
						\item OAuth approach: the external service \emph{just helps the authentication}, giving the user a code in order to sign on to the principal service
					\end{itemize}
					This is also complicated to implement: an app should (in order to implement OAuth or SAML) complicate a lot its flow of usage (user experience) in order to just authenticate a user.\\
					Moreover, the trusted factor is a SPOF.
					
		\section{Access Control}
			Access control is all the protocols and procedures that \emph{allow or deny} certain operations to be applied on certain resources. This operation is usually performed by a reference monitor, that carries out the verification of the rules and the roles (lol).
			
			\subsection{Discretionary Access Control}
				The resource owner assigns the priviledges to users. It's the most standard access control system: for every user (or entity) a set of permissions is defined that describe the rights of each one. A DAC is defined by 3 set of entities:
				\begin{enumerate}
					\item subjects: the actors, the users
					\item objects: the resources
					\item actions: the actions that subjects can perform on objects, that are restricted by the rules
				\end{enumerate}
				The reference monitor organizes the subjects and the objects in a two entry map that lists what every user can do to each resource. This implementation is called HRU model, due to its designers. What this model also allow is to check if the access control system works as intended: if it can be proven that a user can "upgrade" his permissions \emph{on his own} the system is unsafe by design. This is an undecidable problem btw.\\
				This implementation (let alone the scaling problem) is a little bit difficult to utilize, so alternative implementations are possible, like:
				\begin{itemize}
					\item Authorization tables: DBMS like approach, it's a HRU model with not null entries
					\item Access control lists: used in networking, each objects records his own owners/users
					\item Capability list: each user "remembers" the authorization he got
				\end{itemize}
				See how the last two implementations are just "read the HRU table coloumn by coloumn" and "read the HRU table row by row".
				
			
			\subsection{Mandatory Access Control}
				Clearance / Sensitivity access control management. Based on user's roles combined with "objects' secrecy levels". The idea behind is: do not let users assign priviledges. The priviledges are set by an administrator, that assigns levels to users and to resources. Each user level can access only a subset of the resource level. This is usually combined with a labeling system that categorizes in a finer way the resources, orthogonally to the secrecy level.\\
				Then, read/write accesses are granted as rules, for example
				\begin{itemize}
					\item No read up
					\item No write down
				\end{itemize}
			
			\subsection{Role Based Access Control}
				RBAC is kinda a hybrid of DAC and MAC, and can also enforce them: if configured in the right way, it can act as a DAC or as a MAC. The idea is similar to the one that driven MAC design ("no self assigning dynamic priviledges") but the roles are no more structured in a rigid hierarchy but instead are simply \emph{a label to a set of priviledges}.
					
	\part{Software Security}		
		\section{What is software security?}
			With "software security" is intended the meeting of the non-functional requirement (obviously for a software) of \emph{being secure}. This is often overlooked in the process of software developing, but to remind the importance of this non functional requirement, it's sufficient to think about the name of the unmet security specifications: \textbf{vulnerability}.\\
			Recap on definitions:
			\begin{itemize}
				\item Vulnerability: fault in the target software/system
				\item Exploit: method to leverage a vulnerability to harm a system
			\end{itemize}
			
			\paragraph{Vulnerability / Attack relationship}
				\begin{figure}[H]
					\centering
					\includegraphics[width = \textwidth]{./images/vulLifeCycle.png}
				\end{figure}
				This graph explains how the vulnerability life cycle interacts with the actual attacks cycle to a software. To be noted:
				\begin{itemize}
					\item zero days attacks happens when the vulnerability is "out in the wild", known only to hackers
					\item at the moment the vulnerability is \emph{exposed to the public} other security firms can start working on side solutions to limit attacks, weakening the actual attackers margin
					\item the window of exposure is closed \emph{ONLY} after the patch is installed \emph{everywhere}
				\end{itemize}
				
		\section{Principles of Secure Design}
			We can define a list of principles, guidelines, to create a secure software:
			\begin{itemize}
				\item Reduce the privileged parts to the minimum to avoid permissions vulnerability windows
				\item KISS principle, reduce the complexity of a software
				\item Avoid shared resources, or unsafe external libraries. Use instead safe and known secure libraries
				\item Default deny principle: allow only authorized operations
				\item Use filters on input and output
			\end{itemize}
			
		\section{Vulnerabilities}
			\subsection{Buffer Overflow}
				Memory vulnerability, one of the most famous technique to exploit a software. Practically, it means that a piece of data is inserted in a buffer that is smaller. This enables the attacker to overwrite "sensitive" portion of the memory, and (in the worst case) inject malicious code. The thing that makes buffer overflow so dangerous is the way a buffer is allocated in 99\% of cases, so calling a function that does that: this allows the attacker to \emph{directly overwrite the return address from that function}.
				
				\subsubsection{Buffer Overflow HowTo}
					\begin{enumerate}
						\item Find the right address
						\item Create the shellcode
						\item Insert a nop sled
					\end{enumerate}
					
				\subsubsection{Buffer Overflow Defense}
					Defending against buffer overflow means defending against a super powerful type of vulnerabilities that can harm a whole software. This kind of defense can be put in place in three main regions:
					
					\paragraph{Source Code Level}
						The source code is where the vulnerabilities is rooted. Making the source code safe from potential buffer overflow means \emph{educating developers} and \emph{using safe libraries} or safe version of already written libraries. The technology stack should be secure too!
						
					\paragraph{Compiler Level}
						The compiler can inform the developer of the possible vulnerabilities, butthis still rely on the human. Another approach is to change the order (randomizing) of the arguments onto the stack. \emph{BUT} this is only temporary, as the buffer overflow is still there and can be found by exploiters by analyzing the output of the compiler, the binaries.\\
						The "canary mechanism" is also used: a spy is put on top of the stack (the canary is put by the prologue of the function) and then verified by the epilogue. If the canary is different, then the function has been overflowed, and the program has been compromised. Multiple approaches can be applied to canaries:
						\begin{itemize}
							\item Random-per-run canaries: each run of the program the canary is changed
							\item XORandom canaries: the value of the canary is obtained \emph{from the data it's trying to protect}, preventing further unwanted memory modification
							\item Terminator canaries: the canary is entirely made up of terminator characters (so cannot be stringcopied)
						\end{itemize}
						
					\paragraph{OS Level}
						The OS has two main mitigation that can use:
						\begin{itemize}
							\item Non executable stack, so flagging some portion of the memory as data-only. This does not mitigate the "return to a function" type of attacks.
							\item Address space layout randomization: scrambling the memory pages layout. This renders quasi-impossible guessing rightly the return address.
						\end{itemize}
						
			\subsection{Format String}
				Format string vulnerabilities creep out near printing function, when these are "badly formatted": no format (or a wrong one) is provided to print the parameters. Classical example: passing a placeholders-only string to a printf without formatting will print the content of the memory filling that placeholder, \emph{disclosing information}.
				
				\subsubsection{Exploiting Format String Bug in a ANSI C Program}
					We have several placeholders and placeholders extensions we can use to make a format string vulnerability super dangerous.\\
					Placeholders:
					\begin{enumerate}
						\item \%d and \%i to print integers
						\item \%u to print unsigned decimals
						\item \%X and \%x to print unsigned hexadecimals
						\item \%o for octals
						\item \%c for chars, \%s for strings
					\end{enumerate}
					Placeholder modifiers (of interest):
					\begin{enumerate}
						\item N\$: if inserted between the \% and the placeholder character tells the formatter to go to the N-th parameter.
						\item \%n: this placeholder \emph{writes the number of chars printed} so far to the address pointed \emph{by the argument}. The important thing is: whatever value is in the memory \emph{where the argument is searched}, it will be interpeted as a memory location. We will also use his brother \%hn, that writes a shortint.
						\item also, the \%c placeholders for chars can be extended as \%Nc where N is the number of times the first char argument must be prented.
					\end{enumerate}
					So, how do we exploit this?\\
					First of all, we can build a "memory scanner" with just "\%N\$x" and iterating over N: this will print the hexadecimal code of all the "arguments" (memory slots) after the one passed as an argument. Remember, we're sure to be on the stack of the application, because this bug targets \emph{printing functions}, and the exploit string will be the parameter of such function. This is already a vulnerability: we can exploit this to make tha pplication leak information by \emph{directly accessing its memory space}.\\
					To also write, obviously we need to use \%n. We must combine the character-generating placeholder \%Nc and the target-sniping placeholder N\$ in order to obtain the right alignement of the memory and to write \emph{exactly there}. This also highlights the main difference between a buffer overflow vulnerabilty and a format string one: while the BOF acts as a tank overwriting all the memory it traveses, the format string modify exactly the portion of memory needed, leaving the rest unchanged. 
					
					\paragraph{Format String in Practice}
						What we need:
						\begin{itemize}
							\item A target address, the one that represents the block of memory \emph{to be overwritten};
							\item An arbitrary piece of data (could be another address, an arbitrary number, a set of flags...) \emph{that we want to write in memory}
						\end{itemize}
						What do we need to do:
						\begin{enumerate}
							\item suppose we already know the target address of the memory portion to tamper, we need to put this address \emph{exactly} in the position that the \%n will point. To do so, we use the memory-scanner we've presented previously, to finde the offset of it. For now, our string is composed only by the target address.
							\item at this point we need to introduce in our malicious string the data we want to write. To do so, we concatenate the target address with the malicious data generated by the \%Nc placeholder. We now have, as exploit string, "hex of target address + \% (malicious data in decimal - address dimension) c".
							\item lastly, we need to combine the previous step with the writing placeholder \%n. Where do we write (so, which value do I insert in the N\$ parameter of the placeholder)? We need to write in the target address \\$\Rightarrow$ we have put the target address on the stack\\$\Rightarrow$ we have discovered the offset of such address by scanning the memory\\$\Rightarrow$ we put that offset here.
						\end{enumerate}
						Our final string is something resembling
						\begin{equation}
							\begin{cases}
								\text{target address } TA\\
								\text{malicious data } MD\\
								\text{offset of the target address } OFF\\
							\end{cases}
							\Rightarrow TA \,\%MD\, c\%\,OFF\,\$n 
						\end{equation}
						So a valid exploit could be "\textbackslash xcc\textbackslash xff\textbackslash x86\textbackslash x92\%420c3n": it writes "420" in the \textbackslash xcc\textbackslash xff\textbackslash x86\textbackslash x92 memory cell, and the address is memorized as third parameter after the function.
						
					\paragraph{Writing Multiple Locations}
						What if, for example, we want to write into memory (as the malicious data) a valid address, and this address occupies more than one word? Can we write \emph{multiple times} with the same exploit? Yes sir we can. This procedure involves a little bit of additional math, but it's pretty straightforward. First of all, the abstract of the metod: \emph{we use two times th \%N\$n writing mechanism putting two consecutive addresses on the memory, as parameters for N\$}. Whats the problem here? The problem here is that the second write is bounded to go \emph{over} (address speaking) the first one. So, we need to split our malicious data in two part, and write first the "litle" (in module) part.\\
						More difficult said than done, trust me. It's very intuitive: the \%Nc placeholder can elongate the string of N characters, then (if we repeat the mechanism afterwards, \%Mc) add another M characters. Oviously, M cannot be less than zero, so we need to write \emph{first} the "lower" (in absolute value) part of the malicious data and then the "higher" (as remaining part).\\
						The final exploit turns out to be something like
						\begin{equation}
							\begin{cases}
								\text{target addresses } TA, \,TA+1\\
								\text{malicious data } MD\\
								\text{offset of the target address } OFF, \,OFF+1\\
							\end{cases}
						\end{equation}
						\begin{equation}
							(TA) (TA+1) \,\%low\vert\,MD\,\vert\, c\%(OFF)\$n\%(high - low)\vert\,MD\vert\,c\%(OFF+1)\$n
						\end{equation}
						
						\subparagraph{Quick Note on this Part}
							So I think I was not totally accurate in writing these notes, so I'll put the professor recap from \emph{his slides} right here in the notes.
							\begin{figure}[H]
								\centering
								\begin{minipage}{0.45\textwidth}
									\centering
									\includegraphics[width = 0.9\textwidth]{./images/formatStringRecap1.png}
								\end{minipage}\hfill
								\begin{minipage}{0.45\textwidth}
									\centering
									\includegraphics[width = 0.9\textwidth]{./images/formatStringRecap2.png} 
								\end{minipage}
							\end{figure}						
					
	
	\part{Web Security}
		\section{What is Web Security?}
			The main difference between a "traditional" software attack and a web attack is often only the exposure of the app itself. This is also the motivation that renders the web attacks so impactful and web vulnerabilities so crucial to solve.
			
			\subsection{Architectural View of an Attack}
				Let's talk about the classic 3 tiered architecture:
				\begin{enumerate}
					\item Client and presentation layer
					\item Controller layer
					\item Persistence / Data layer
				\end{enumerate}
				HTTP connects the first two layers (and often also the two back ones). The statelessness of HTTP is also the major securty issue: it provides \emph{determinism} in the behaviour of the web applications. Also, it's text based; easy to counterfeit. 
				
		\section{Filtering}
			Filtering is the first line of defence wrt any kind of attack. It's obvious: if an attacker \emph{cannot add malicious stuff} or \emph{cannot even access dangerous services} it cannot harm. BUT filtering is hard: what do you filter? What do you blacklist? This is the classic filter system build:
			\begin{enumerate}
				\item Start with a whitelist approach (deny all except allowed)
				\item Proceed "a regime" with a blacklist method (deny bad people)
				\item Perform \emph{escaping}, so neutralize possible malicious inputs
			\end{enumerate}
			Filtering also comes into play when it's time to separate the data from the executables: when the data can be executed, when it's just data?
			
			\subsection{Filtering Problems: Cross Site Scripting}
				Cross Site Scripting (XSS) is a kind of attack that just occurs when \emph{data is not differentiated enough from code}. MSN allowed you to enter HTML an JS code into comments, but a JS-written comment will \emph{executed byb all the people that visit that page}. We can distinguish three type of XSS: Stored, Reflected and DOM-based XSSs.
				
				\paragraph{Stored XSS}
					The MSN example. The attacker can memorize malicious code in the server and this is then propagated to other clients. This happens if the malicious code is not recognized as such; all the clients that download the malicious resource find valid code to be executed, and blindly execute it.
					
				\paragraph{Reflected XSS}
					Reflected XSS does not rely on the server \emph{to memorize the exploit}: the attacker usually craft a malicious packet (or request, or site itself) and sends it directly to the victim. This request will \emph{trigger an existing vulnerability} in a site (that can also be totally unaware of it).
				
				\paragraph{DOM based XSS}
					DOM based attacks are similar to reflected attacks (in fact, the idea is the same; often also the implementation). The main difference is that the server is completely cut off from the attack: the reflection of the malicious code is handled by the \emph{client side code} such as javascript scripts built in pages. These kind of attacks are just pumped up reflected XSS attacks.
				
			\subsection{Content Security Policy}
				CSP is a HTTP based technique to reduce the possibility on XSS by enforcing the Same Origin Principle. It embeds into HTTP headers some indicators that lists which resources (and which origins, extensions, formats) are safe and which not. This measure is clever, but suffers the eternal engineering burden: how much is enough? When I'm filtering enough shit without breaking functionality? 
	
	\part{Exercises and Examples}
		\section{Exercises}
			\subsection{Identity theft}
				Which are the risk components in the scenario of identity theft, like in social media platforms?
				\begin{enumerate}
					\item Reputation threathened both of the victim and the company
					\item Social engineering attacks
					\item Malicious spread of information
				\end{enumerate}
				And the assets?
				\begin{enumerate}
					\item reputation
					\item money
					\item personal information
				\end{enumerate}
				And who are the threat agents?
				\begin{enumerate}
					\item People around you
					\item Government
					\item etc
				\end{enumerate}
				So \emph{everybody} with a malicious intent\\
				Why is this scenario possible, and how to mitigate it?
				\begin{enumerate}
					\item 2FA
					\item trusted device based auth
					\item enforce credentials strongness
				\end{enumerate}
				
			\subsection{Ransomware attack}
				A small company specialized in a particular object is infected by a ransomware\\
				What are the threats, the asset at risk and the possible countermeasures?\\
				First:
				\begin{itemize}
					\item data loss
					\item data of the company
					\item offline backups
				\end{itemize}
				Second:
				\begin{itemize}
					\item data leakage
					\item data of the company
					\item encryption
				\end{itemize}
				Third:
				\begin{itemize}
					\item denial of service
					\item production
					\item redundancy
				\end{itemize}
				Who are the possible threat agents? Cuncurrent companies, ex internal employees, ransomers...
				
			\subsection{Auto driving vehicles}
				Consider auto driving cars used as taxies.\\
				Which are the most valuable assets in this scenario?
				\begin{enumerate}
					\item People inside the car
					\item People outside the car
					\item the vehicle itself
				\end{enumerate}
				What are the attack surfaces on the vehicles?
				\begin{enumerate}
					\item The VEHICLE itself, you enter there!
					\item the connectivity capabilities of the vehicle
					\item the company network, or the internet itself (it was an hypothesis)
				\end{enumerate}
				
	\part{x86 assembly recap and pwndbg}
		\section{Recap of software compiling}
			Code is translated by the compiler in Assembly code that is the assembled in binary code. That's the workflow. The process is theoretically not reversible, it can be reconduced to the halting problem. This is due to the loss of information (for example about types in the first step) that the process introduces.
			
		\section{The x86 ISA}
			64 bit CISC architecture for original Intel processors.\\
			Register file:
			\begin{enumerate}
				\item EAX EBX ECX EDX
				\item ESI EDI for strings
				\item EBP ESP base and stack pointers
				\item EIP instruction pointer, never explicitly accessed
				\item EFLAGS program status and control 
			\end{enumerate}
			The "E" before the register name stands for "extended" and references the 64 bit version of the register. Omitting it will access the 32 bit version.
			
			\subsection{Data types}
				Four main "data types"
				\begin{enumerate}
					\item Byte - 8 bit
					\item Word - 2 Bytes
					\item Dword - 2 Words
					\item Qword - 4 Words
				\end{enumerate}
			
			\subsection{Instructions}
				Instructions in x86 have \emph{variable lenght} ranging from 1 byte to 16 bytes. Every instruction is composed of the opcode (representing the operation) and the operand list. We'll be using logic, memory, arithmetic and control flow instructions.

		\section{Executables and binaries}
			Binary files, although different for each operative system, all (more or less) follow a fixed schema to encode operations and data. Usually, this schema involves a DATA and a TEXT section, respectively for the data and the instructions; it usually has also a section where offsets in memory (to describe the memory structure \emph{of the program}) are stored. Usually (starting from the lowest and going to the highest memory addresses) this is the schema:
			\begin{enumerate}
				\item Shared libraries
				\item .text
				\item .bss
				\item the heap (that grows \emph{towards high addresses})
				\item the stack (that grows \emph{towards low addresses})
				\item \emph{env}
				\item \emph{argv}
			\end{enumerate}
			



\end{document}
